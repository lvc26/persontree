#include "Person.h"
#include <memory>
#include <vector>

/** \brief Узел бинарного дерева. */
struct tree_node
{
  /***********************************************************************************************//**
  *     \brief Конструктор, создающий узел дерева и инициализирующий его значение, а также указатель на
  *     родительский узел.
  *
  *     \param val    Значение узла - экземпляр структуры Person.
  *     \param parent Указатель на родительский узел.
  ****************************************************************************************************/
  tree_node(const Person &val, tree_node *parent) : value(val), up(parent)
  {
  }

  Person value; ///< Персональные данные
  tree_node *up;  ///< Указатель на родительский узел, для корня дерева - nullptr
  std::unique_ptr<tree_node> left;  ///< Дочерний узел слева
  std::unique_ptr<tree_node> right; ///< Дочерний узел справа
};

/** \brief Бинарное дерево, хранящее в узлах структуры Person с персональными данными. */
struct tree
{
  std::unique_ptr<tree_node> root;  ///< Корневой узел двоичного дерева

  /***********************************************************************************************//**
  *     \brief Вставляет (встраивает) узел в структуру двоичного дерева
  *
  *     \param val Персональные данные.
  *
  *     \return Null при неудаче, иначе - указатель на добавленный узел.
  ****************************************************************************************************/
  tree_node * insert(const Person &val);

  /***********************************************************************************************//**
  *     \brief Ищет и удаляет узел из дерева, перестраивая его структуру
  *
  *     \param val Данные, которые следует удалить.
  *
  *     \return True в случае успеха, false - в противном случае.
  ****************************************************************************************************/
  bool remove(const Person &val);

  /***********************************************************************************************//**
  *     \brief Преобразует данные дерева в сортированный вектор
  *
  *     \return Вектор структур Person.
  ****************************************************************************************************/
  std::vector<Person> to_vector() const;

  /***********************************************************************************************//**
  *     \brief Загружает двоичное дерево из CSV-файла
  *
  *     \param path Путь к файлу для загрузки.
  *
  *     \return True в случае успеха, false - в противном случае.
  ****************************************************************************************************/
  bool load(const std::string &path);

  /***********************************************************************************************//**
  *     \brief Сохраняет двоичное дерево в CSV-файл
  *
  *     \param path Путь к файлу для сохранения.
  *
  *     \return True в случае успеха, false - в противном случае.
  ****************************************************************************************************/
  bool save(const std::string &path) const;

  /***********************************************************************************************//**
  *     \brief Поиск в двоичном дереве узла с персональными данными по номеру телефона.
  *
  *     \param phone Номер телефона.
  *
  *     \return Null в случае неудачи, иначе - указатель на найденный tree_node.
  ****************************************************************************************************/
  tree_node * find(const Phone &phone) const;
};
